% Introduction
% ============

\chapter{Introduction}
\label{ch:introduction}

\section{Qu'est-ce que la calculabilité}
\label{sec:qu_est-ce_la_calculabilite}

\section{Qu'est-ce que la calculabilité}
\paragraph{}

La calculabilité c'est l'étude des limites de l'informatique. Il faut bien
faire attention à faire la différence entre les limites théoriques et les limites
pratiques. Pour la calculabilité, on s'occupe des limites théoriques alors que pour 
la complexité on s'occupe des limites pratiques. La complexité
détermine la frontière entre ce qui est faisable et infaisable en pratique.
La question principale de la calculabilité est: ``quels sont les problèmes qui peuvent
être résolus par un programme?''. La caractéristique de calculabilité ne donne aucune 
autre information sur le programme que de la preuve de son existence.

\paragraph{} Le but est donc de tracer des frontières entre les programmes calculables,
non calculables et non calculables en pratique.

\paragraph{}
Cela nous permet de savoir quand ça ne sert à rien d'essayer de résoudre un problème.
De plus, on est conscient de la complexité intrinsèque d'un problème.
% paragraph  (end)

\subsection{Exemples de limites}
\label{subsec:exemples_limites}

De nombreuses limites existent en informatique, par exemple il est impossible de déterminer quand un programme se termine. Ou bien on ne peut pas déterminer qu'un programme est écrit sans bugs.

Mais des limites existent dans bien d'autres domaines que l'informatique. 
Par exemple dans plusieurs champs de la physique, on retrouve les lois de la 
thermodynamique dans ce rôle. En effet on ne peut créer de l'énergie à partir de rien.

En biologie, les lois de Mendel forment une limite. Un individu ne peut recevoir 
d'autres gènes que ceux de sa propre famille. %Verifier si c'est bien pertinent

\section{Notion de problème}
\label{sec:notion_de_probl_me}

\paragraph{}
Premièrement, on doit parler de la notion de problème.
Attention, il ne faut pas confondre un problème avec un programme.
Les caractéristiques d'un problème sont:

\begin{itemize}
	\item un problème est générique : il s'applique à un ensemble de données.
	\item pour chaque donnée particulière, il existe une réponse.
\end{itemize}
On représente un problème dans le cours par une fonction. Donc dans le cours,
la description d'un problème est équivalente à la description d'une fonction.
% paragraph  (end)
% subsection notion_de_probl_me (end)

\section{Notion de programme}
\label{sec:notion_de_programme}

Un programme est une ``procédure effective'', c'est-à-dire exécutable par une machine.
Il existe plein de formalismes permettant la description de ``procédure effective''.

% subsection notion_de_programme (end)

\section{Résultats principaux}
\label{sec:r_sultat_principaux}


	\subsection{ Équivalence des langages de programmation}
	 Il a t-il de langage de programmation qui sont plus puissantes que d'autres ?  Il a des langages qui sont équivalents ? 
	\newline Il y a une équivalence entre langages en termes de calculabilité quand un problème qui peut être résolu par un de ces langages peut être résolu par n'importe lequel autre.   
S'il existe un programme Java qui résoudre un problème il existera aussi un programme C/C++, PHP, … qui peut résoudre le même problème, on peut dire qu'il existe une équivalence théorique.\\
 D'un point de vue théorique ce langages s'appellent des langages complets, complet ça veut dire qu'il permet tous de résoudre le même problème donc le problème calculable à ces langages sont tous le même.\\
D'un point de vue pratique on peut voir des différences (le programme sera plus court, s'écrire plus rapidement, le programme sera plus rapide, plus propre, plus fiable et encore d'autres critères) c'est le langage le plus adapté qui aura un avantage. 


	\subsection{Existence de problèmes non calculables}
	Problème non calculable : il existe des problèmes qui ne peuvent
		être résolus par un programme. Ex:
        détection de virus,
        équivalence de programme,
        déterminer si un polynôme à coefficients entiers à des racines entières, ...
	

% section r_sultat_principaux (end)


\section{Détection de virus}
\label{sec:d_tection_de_virus}
On veut déterminer si un programme P avec une entrée D est nuisible.

\textbf{Être nuisible:} Un programme est dit nuisible si son exécution a pour effet de contaminer d'autres programme, le programme va se recopier autre part. 

Spécification du programme detecteur(P,D):\\
\textbf{Préconditions :} un programme P et une donnée D\\
\textbf{Postconditions :} ``Mauvais'' si P(D) est nuisible,
		``Bon'' sinon.
Il faut aussi que detecteur ne soit pas nuisible.

On va créer un programme drole(P) et essayer de détecter s’il est nuisible.

\begin{lstlisting}
drole(P)
if detecteur(P,P) = ``Mauvais''
	then stop
else infecter un autre programme en y inserant P
\end{lstlisting}

Testons \lstinline|drole(drole)|.
\begin{lstlisting}
drole(drole)
if detecteur(drole, drole) = ``Mauvais''
	then stop
else infecter un autre programme en y inserant drole
\end{lstlisting}

\begin{itemize}
	\item Supposons que \lstinline|drole(drole)| soit nuisible.
      Lorsqu'on exécute, \lstinline|drole(drole)|
      \lstinline|detecteur(drole,drole)| n'infecte rien car \lstinline|detecteur| n'est pas nuisible.
      Comme \lstinline|detecteur| retourne ``Mauvais'',
      le programme s'arrête.
      Rien a donc été infecté, ce qui est contradictoire avec le fait que \lstinline|drole(drole)| est nuisible.
	\item Si par contre il n'est pas nuisible alors \lstinline|detecteur(drole,drole)|
      ne va pas retourner Mauvais et on va arriver dans le \lstinline|else|.
      On a donc infecter un autre programe que qui contredit le fait que \lstinline|drole(drole)| n'est pas nuisible.
\end{itemize}

On a donc une contradiction dans tous les cas ce qui implique que le programme \lstinline|drole| ne peut
exister, ce qui implique que le programme detecteur non plus.
% paragraph  (end)
% subsection d_tection_de_virus (end)

\subsection{ Existence de problèmes intrinsèquement complexes}
	Problème intrinsèquement complexe. (Voir complexité) Les problèmes
		qui ont une complexité supérieure ou égale à l'exponentielle. Peu importe les évolutions technologiques, un problème exponentiel ne peut et ne pourra être résolu que pour de petite taille, par exemple le problème du voyageur de commerce. 
		
\section{Objectifs calculabilité et complexité}

A la Fig(\ref{cal_non_cal}) on voit qu'il a une frontière entre les problème non calculables (il n'existe pas un programme) et calculables (il existe un programme),  dans les calculables il a ceux qui sont calculables en pratiques (pas exponentiel) et puis ce qui ne sont pas calculables en pratique. 

\begin{figure}[h]
  \centering
  \includegraphics[width=0.55\textwidth]{Images/Problemes_calculables_et_non_calculables.png}
  \caption{ Problèmes calculables / non calculables }
  \label{cal_non_cal}
\end{figure}

L'intérêt de la calculabilité est de savoir quel problème sont calculables ou pas et donc ne pas essayer de résoudre un problème non calculable. S'il le problème est calculable il faut analyser la complexité pour savoir s'il y a une solution pratique pour la taille de mon problème. 

% section introduction (end)Introduction


